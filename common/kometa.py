"""Helpers for producing and writing Kometa-compatible collection entries."""

from __future__ import annotations

import datetime
import os
import re
import subprocess
from pathlib import Path
from typing import Dict, Iterable, Mapping, MutableMapping, Sequence


START_MARKER = "#lbd-lists-begin"
END_MARKER = "#lbd-lists-end"


def _normalize_letterboxd_source(
    source: str | Sequence[str] | Iterable[str],
) -> str | list[str]:
    if isinstance(source, str):
        return source
    if isinstance(source, Sequence):
        return [str(item) for item in source]
    return [str(item) for item in source]


def build_collection_entry(
    source: str | Sequence[str] | Iterable[str],
    *,
    sort_title: str,
    collection_order: str = "custom",
    sync_mode: str = "sync",
    summary: str | None = None,
    visible_library: bool | None = None,
    visible_home: bool | None = None,
    visible_shared: bool | None = None,
    extra: Mapping[str, object] | None = None,
) -> MutableMapping[str, object]:
    """Return a Kometa collection configuration mapping."""

    entry: MutableMapping[str, object] = {
        "letterboxd_list": _normalize_letterboxd_source(source),
        "collection_order": collection_order,
        "sort_title": sort_title,
        "sync_mode": sync_mode,
    }

    if summary:
        entry["summary"] = summary

    visibility = {
        "visible_library": visible_library,
        "visible_home": visible_home,
        "visible_shared": visible_shared,
    }
    for key, value in visibility.items():
        if value is not None:
            entry[key] = value

    if extra:
        entry.update(extra)

    return entry


def write_collections_section(
    destination: str | Path,
    collections: Dict[str, Dict[str, object]],
    *,
    generator: str,
    config_source: str | Path,
) -> None:
    output_path = Path(destination).expanduser()
    try:
        content = output_path.read_text()
    except FileNotFoundError:
        raise FileNotFoundError(f"Kometa config file not found at {output_path}")

    pattern = re.compile(
        r"^\s*" + re.escape(START_MARKER) + r".*?^\s*" + re.escape(END_MARKER),
        re.DOTALL | re.MULTILINE,
    )

    if not pattern.search(content):
        raise ValueError(
            f"File {output_path} lacks required markers '{START_MARKER}' and '{END_MARKER}'"
        )

    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    config_name = Path(config_source).name

    try:
        kometa_hash = (
            subprocess.check_output(
                ["git", "rev-parse", "--short", "HEAD"],
                cwd=os.path.expanduser("/opt/kometa"),
                stderr=subprocess.DEVNULL,
            )
            .decode()
            .strip()
        )
    except Exception:
        kometa_hash = "unknown"

    new_section = [
        f"  {START_MARKER}",
        f"  # Generated by {generator} on {timestamp}",
        f"  # Kometa git hash: {kometa_hash}",
        f"  # This section is managed by {generator}",
        f"  # Configuration loaded from {config_name}",
        "  # Any manual changes within the markers will be overwritten.",
        "",
    ]

    for collection_name, collection_config in collections.items():
        new_section.append(f'  "{collection_name}":')
        for key, value in collection_config.items():
            if key.startswith("#"):
                new_section.append(f"    {key}: {value}")
            elif isinstance(value, list):
                new_section.append(f"    {key}:")
                for item in value:
                    new_section.append(f"      - {item}")
            elif isinstance(value, bool):
                new_section.append(f"    {key}: {str(value).lower()}")
            else:
                new_section.append(f"    {key}: {value}")
        new_section.append("")

    new_section.append(f"  {END_MARKER}")
    replacement = "\n".join(new_section)

    updated_content = pattern.sub(replacement, content)

    lines = [line.rstrip() for line in updated_content.split("\n")]
    while lines and lines[-1] == "":
        lines.pop()
    updated_content = "\n".join(lines) + "\n"

    output_path.write_text(updated_content)
