"""Helpers for producing and writing Kometa-compatible collection entries."""

from __future__ import annotations

import datetime
import os
import re
import subprocess
import yaml
from pathlib import Path
from typing import Dict, Iterable, Mapping, MutableMapping, Sequence


START_MARKER = "#lbd-lists-begin"
END_MARKER = "#lbd-lists-end"


def _normalize_letterboxd_source(
    source: str | Sequence[str] | Iterable[str],
) -> str | list[str]:
    if isinstance(source, str):
        return source
    if isinstance(source, Sequence):
        return [str(item) for item in source]
    return [str(item) for item in source]


def build_collection_entry(
    source: str | Sequence[str] | Iterable[str],
    *,
    sort_title: str,
    collection_order: str = "custom",
    sync_mode: str = "sync",
    summary: str | None = None,
    visible_library: bool | None = None,
    visible_home: bool | None = None,
    visible_shared: bool | None = None,
    extra: Mapping[str, object] | None = None,
    tmdb_ids: Sequence[str] | None = None,
) -> MutableMapping[str, object]:
    """Return a Kometa collection configuration mapping."""

    entry: MutableMapping[str, object] = {
        "sort_title": sort_title,
        "sync_mode": sync_mode,
    }

    if collection_order is not None:
        entry["collection_order"] = collection_order

    # Use tmdb_movie if TMDB IDs are provided, otherwise use letterboxd_list
    if tmdb_ids:
        entry["tmdb_movie"] = list(tmdb_ids)
    else:
        entry["letterboxd_list"] = _normalize_letterboxd_source(source)

    if summary:
        entry["summary"] = summary

    visibility = {
        "visible_library": visible_library,
        "visible_home": visible_home,
        "visible_shared": visible_shared,
    }
    for key, value in visibility.items():
        if value is not None:
            entry[key] = value

    if extra:
        entry.update(extra)

    return entry


def write_collections_section(
    destination: str | Path,
    collections: Dict[str, Dict[str, object]],
    *,
    generator: str,
    config_source: str | Path,
) -> None:
    output_path = Path(destination).expanduser()
    try:
        content = output_path.read_text()
    except FileNotFoundError:
        raise FileNotFoundError(f"Kometa config file not found at {output_path}")

    pattern = re.compile(
        r"^\s*" + re.escape(START_MARKER) + r".*?^\s*" + re.escape(END_MARKER),
        re.DOTALL | re.MULTILINE,
    )

    if not pattern.search(content):
        raise ValueError(
            f"File {output_path} lacks required markers '{START_MARKER}' and "
            f"'{END_MARKER}'"
        )

    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    config_name = Path(config_source).name

    try:
        kometa_hash = (
            subprocess.check_output(
                ["git", "rev-parse", "--short", "HEAD"],
                cwd=os.path.expanduser("/opt/kometa"),
                stderr=subprocess.DEVNULL,
            )
            .decode()
            .strip()
        )
    except Exception:
        kometa_hash = "unknown"

    # Create the collections section using proper YAML
    collections_data = {"collections": collections}

    # Generate YAML with proper formatting
    yaml_content = yaml.safe_dump(
        collections_data,
        default_flow_style=False,
        sort_keys=False,
        allow_unicode=True,
        width=120,
        indent=2,
    )

    # Extract just the collections part (remove the top-level "collections:" line)
    yaml_lines = yaml_content.split("\n")
    if yaml_lines[0] == "collections:":
        yaml_lines = yaml_lines[1:]  # Remove the first line

    # Indent the YAML content properly (2 spaces for collections section)
    indented_yaml_lines = []
    for line in yaml_lines:
        if line.strip():  # Only indent non-empty lines
            indented_yaml_lines.append(f"  {line}")
        elif line == "":  # Preserve empty lines
            indented_yaml_lines.append("")

    # Build the new section with header comments and proper YAML
    new_section = [
        f"  {START_MARKER}",
        f"  # Generated by {generator} on {timestamp}",
        f"  # Kometa git hash: {kometa_hash}",
        f"  # This section is managed by {generator}",
        f"  # Configuration loaded from {config_name}",
        "  # Any manual changes within the markers will be overwritten.",
        "",
    ]

    new_section.extend(indented_yaml_lines)
    new_section.append(f"  {END_MARKER}")

    replacement = "\n".join(new_section)

    updated_content = pattern.sub(replacement, content)

    lines = [line.rstrip() for line in updated_content.split("\n")]
    while lines and lines[-1] == "":
        lines.pop()
    updated_content = "\n".join(lines) + "\n"

    output_path.write_text(updated_content)
