"""Helpers for producing and writing Kometa-compatible collection entries."""

from __future__ import annotations

import datetime
import os
import subprocess
from pathlib import Path
from typing import Dict, Iterable, Mapping, MutableMapping, Sequence

import yaml


def _normalize_letterboxd_source(
    source: str | Sequence[str] | Iterable[str],
) -> str | list[str]:
    if isinstance(source, str):
        return source
    if isinstance(source, Sequence):
        return [str(item) for item in source]
    return [str(item) for item in source]


def build_collection_entry(
    source: str | Sequence[str] | Iterable[str],
    *,
    sort_title: str,
    collection_order: str = "custom",
    sync_mode: str = "sync",
    summary: str | None = None,
    visible_library: bool | None = None,
    visible_home: bool | None = None,
    visible_shared: bool | None = None,
    extra: Mapping[str, object] | None = None,
    tmdb_ids: Sequence[str] | None = None,
) -> MutableMapping[str, object]:
    """Return a Kometa collection configuration mapping."""

    entry: MutableMapping[str, object] = {
        "sort_title": sort_title,
        "sync_mode": sync_mode,
    }

    if collection_order is not None:
        entry["collection_order"] = collection_order

    # Use tmdb_movie if TMDB IDs are provided, otherwise use letterboxd_list
    if tmdb_ids:
        entry["tmdb_movie"] = list(tmdb_ids)
    else:
        entry["letterboxd_list"] = _normalize_letterboxd_source(source)

    if summary:
        entry["summary"] = summary

    visibility = {
        "visible_library": visible_library,
        "visible_home": visible_home,
        "visible_shared": visible_shared,
    }
    for key, value in visibility.items():
        if value is not None:
            entry[key] = value

    if extra:
        entry.update(extra)

    return entry


def write_collections_section(
    destination: str | Path,
    collections: Dict[str, Dict[str, object]],
    *,
    generator: str,
    config_source: str | Path,
    delete_collections_named: Sequence[str] | None = None,
) -> None:
    """Merge the provided collections into a Kometa YAML file."""

    output_path = Path(destination).expanduser()

    try:
        if output_path.exists():
            with output_path.open("r", encoding="utf-8") as handle:
                file_data = yaml.safe_load(handle) or {}
        else:
            raise FileNotFoundError
    except FileNotFoundError:
        raise FileNotFoundError(f"Kometa config file not found at {output_path}")

    if not isinstance(file_data, dict):
        raise ValueError(f"Kometa config at {output_path} must be a mapping")

    # Replace the collections section entirely with the freshly generated mapping.
    file_data["collections"] = dict(collections)

    if delete_collections_named:
        file_data["delete_collections_named"] = list(delete_collections_named)
    else:
        file_data.pop("delete_collections_named", None)

    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    config_name = Path(config_source).name

    try:
        kometa_hash = (
            subprocess.check_output(
                ["git", "rev-parse", "--short", "HEAD"],
                cwd=os.path.expanduser("/opt/kometa"),
                stderr=subprocess.DEVNULL,
            )
            .decode()
            .strip()
        )
    except Exception:
        kometa_hash = "unknown"

    with output_path.open("w", encoding="utf-8") as handle:
        handle.write(f"# Generated by {generator} on {timestamp}\n")
        handle.write(f"# Kometa git hash: {kometa_hash}\n")
        handle.write(f"# Configuration loaded from {config_name}\n\n")
        yaml.safe_dump(
            file_data,
            handle,
            default_flow_style=False,
            sort_keys=False,
            allow_unicode=True,
            width=120,
            indent=2,
        )
