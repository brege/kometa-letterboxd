"""Helpers for updating Kometa collection files managed by Letterboxd tooling."""

from __future__ import annotations

import datetime
import os
import re
import subprocess
from pathlib import Path
from typing import Dict


START_MARKER = "#lbd-lists-begin"
END_MARKER = "#lbd-lists-end"


def write_collections_section(
    destination: str | Path,
    collections: Dict[str, Dict[str, object]],
    *,
    generator: str,
    config_source: str | Path,
) -> None:
    output_path = Path(destination).expanduser()
    try:
        content = output_path.read_text()
    except FileNotFoundError:
        output_path.parent.mkdir(parents=True, exist_ok=True)
        content = "collections:\n  #lbd-lists-begin\n  #lbd-lists-end\n"
        output_path.write_text(content)

    pattern = re.compile(
        r"^\s*" + re.escape(START_MARKER) + r".*?^\s*" + re.escape(END_MARKER),
        re.DOTALL | re.MULTILINE,
    )

    if not pattern.search(content):
        raise ValueError(
            f"File {output_path} lacks required markers '{START_MARKER}' and '{END_MARKER}'"
        )

    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    config_name = Path(config_source).name

    try:
        kometa_hash = (
            subprocess.check_output(
                ["git", "rev-parse", "--short", "HEAD"],
                cwd=os.path.expanduser("/opt/kometa"),
                stderr=subprocess.DEVNULL,
            )
            .decode()
            .strip()
        )
    except Exception:
        kometa_hash = "unknown"

    new_section = [
        f"  {START_MARKER}",
        f"  # Generated by {generator} on {timestamp}",
        f"  # Kometa git hash: {kometa_hash}",
        f"  # This section is managed by {generator}",
        f"  # Configuration loaded from {config_name}",
        "  # Any manual changes within the markers will be overwritten.",
        "",
    ]

    for collection_name, collection_config in collections.items():
        new_section.append(f'  "{collection_name}":')
        for key, value in collection_config.items():
            if key.startswith("#"):
                new_section.append(f"    {key}: {value}")
            elif isinstance(value, list):
                new_section.append(f"    {key}:")
                for item in value:
                    new_section.append(f"      - {item}")
            elif isinstance(value, bool):
                new_section.append(f"    {key}: {str(value).lower()}")
            else:
                new_section.append(f"    {key}: {value}")
        new_section.append("")

    new_section.append(f"  {END_MARKER}")
    replacement = "\n".join(new_section)

    updated_content = pattern.sub(replacement, content)

    lines = [line.rstrip() for line in updated_content.split("\n")]
    while lines and lines[-1] == "":
        lines.pop()
    updated_content = "\n".join(lines) + "\n"

    output_path.write_text(updated_content)
